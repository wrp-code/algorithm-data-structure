## 评价时间复杂度的好坏

先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，即“常数项时间”。

> tips: 判断一个算法的优劣不能只看时间复杂度指标O()，还需要根据真实的数据状况来判断。



## 异或运算

> 0 ^ 0 = 0
>
> 0 ^ 1 = 1
>
> 1 ^ 0 = 1
>
> 1 ^ 1 = 0
>
> 
>
> 异或运算满足：
>
> - 交换律 a ^ b = b ^ a
> - 结合律 (a ^ b) ^ c = a ^ (b ^ c) 

```java
private static void swap1(int[] arr, int from, int to) {
    // warning from == to会导致from位置值为0
    if(from == to) return;
    arr[from] = arr[from] ^ arr[to];
    arr[to] = arr[from] ^ arr[to];
    arr[from] = arr[from] ^ arr[to];
}
```



## 求某个值在二进制位上最右的1

> i 		 = 10110100
>
> ~i		= 01001011
>
> ~i + 1  	= 01001100
>
> i & (~i + 1)  = 00000100

```java
public static int rightOne(int i) {
    return i & (~i + 1);
}
```



## 优化算法的入手方面

1. 数况
2. 问题



## Master公式

> 用于计算符合master公式的**递归**的时间复杂度

T(N) = a * T(N / b) + o(N^d)

- T(N) 母问题的规模
- T(N / b) 子问题的规模
- a 子问题调用次数
- o(N^d) 其他调用的规模

三个结论

1. logb a < d ， O(N^d)
2. logb a > d , O(N^logba)
3. logba == d, O(N^d * logN)

```java
public static int getMax(int[] arr, int l, int r) {
    if(l == r) {
        return arr[l];
    }
    int mid = l + ((r - l) >> 1);
    int lMax = getMax(arr, l, mid);
    int rMax = getMax(arr, mid + 1, r);
    return Math.max(lMax, rMax);
}
```

master公式为 T(N) = 2 * T(N / 2) + o(1)，a = 2, b = 2, d = 0 ，此时logba > d，时间复杂度为O(N)



## 堆结构

> 逻辑结构：完全二叉树、满二叉树
>
> 存储结构：数组
>
> 新增或删除值的时间复杂度：O(logN)

- 数组中 i 位置节点的左孩子下标 2 * i + 1；右孩子下标 2* i + 2；父节点 (i - 1) / 2

- 分类：大根堆（任意节点大于其子节点）、小根堆（任意节点小于其子节点）

### API(大根堆)

- heapInsert O(logN)

> 添加一个新值，放在数组最后，如果比父节点大，则与父节点交换，直到比父节点小，或成为根节点。从下往上的一个过程。

- heapify O(logN)

> 删去最大值，即位置为0的值。先把数组最后一个节点放在0位置，左右子节点中的较大值大于当前值，则与较大值交换，直到当前位置大于左右子节点或者成为叶子节点。从上往下的一个过程。



### 问题

- 如果在一个大根堆中，将任意一个位置的值改成了新值，如何调整成为大根堆？
  - 如果新值大于旧值，调用heapInsert
  - 如果新值小于旧值，调用heapify
- 给你一个数组，如何快速的调整成大根堆？
  - 方式1，从0遍历数组，每次heapInsert，模拟生成一个大根堆的过程，O(NlogN)
  - 方式2，从数组最后开始遍历，每次heapify，O(N)，速度更快

- 系统自带的堆结构有什么缺点？
- 系统自带的堆，只能操作堆顶元素，而无法操作任意位置的元素（如将任意位置的数改成新值）。需要自己写堆。

### 相关结构

- 优先级队列，实质就是堆结构，Java中是`PriorityQueue`，默认是小根堆

## 堆排序 O(NlogN)

> 先将数组heapInsert成为一个大根堆，再依次把堆顶元素和最后一个值交换，heapSize--，heapify，直到heapSize=0，排序结束。

### 堆排序扩展题目

> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

准备一个大小为k + 1的小根堆，遍历数组，将前k+1个数入堆，堆顶元素出堆放在0下标，再将第k+2个数入堆，依次类推，直到数组中的元素过一次堆。





## 比较器的使用

> 重载比较运算符
>
> Java中的`Comparator`



## 不基于比较的排序算法

- 计数排序，即词频统计排序

> 如问题：一个包含公司员工的年龄数组，请按年龄从小到大排序。

因为年龄范围有限，可以申请一个200的数组，统计年龄出现的次数，再根据词频复写数组。

- 基数排序，即桶排序

> 十进制数排序，准备10个桶（这里一个桶代表一个队列），依次按个位、十位、百位、千位处理，将数组中的每个数入桶，再将桶从左往右依次出桶。

入桶出桶的操作有优化，根据词频统计再组织成前缀和，分片后从右至左遍历数组，根据前缀和确认值的位置。





## 排序算法汇总

|          | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | ---------- | ---------- | ------ |
| 选择排序 | N²         | 1          | ×      |
| 冒泡排序 | N²         | 1          | √      |
| 插入排序 | N²         | 1          | √      |
| 归并排序 | NlogN      | N          | √      |
| 快速排序 | NlogN      | logN       | ×      |
| 堆排序   | NlogN      | 1          | ×      |
| 计数排序 |            |            | √      |
| 基数排序 |            |            | √      |

优先使用快速排序（常数项低），考虑优先级使用归并排序，考虑空间使用堆排序。

### 常见坑

- 1，归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法” 
- 2， “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2)
- 3，快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01stable sort” 
- 4，所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。
- 5，有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。（类似于快排的partition）

### 工程改进

- 充分利用O(N*logN)和O(N^2)排序各自的优势（快速排序的partition过程中，如果数据量小于K(如60)，则使用插入排序）
- 稳定性的考虑（如基础结构排序使用快排，不需要稳定性；自定义结构排序使用归并，需要稳定性）

 ## 哈希表和有序表

- 哈希表 HashMap、HashSet
  - 时间复杂度O(1)，常数项时间大
- 有序表 TreeMap、TreeSet
  - 时间复杂度O(logN)
  - 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构
  - K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。
  - K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。
  - K floorKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的前一个。
  - K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个。

