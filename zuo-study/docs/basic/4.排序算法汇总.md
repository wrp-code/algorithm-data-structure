## 第四节课

- 排序算法的汇总
- 哈希表和有序表
- 单链表

## 排序算法汇总

|          | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | ---------- | ---------- | ------ |
| 选择排序 | N²         | 1          | ×      |
| 冒泡排序 | N²         | 1          | √      |
| 插入排序 | N²         | 1          | √      |
| 归并排序 | NlogN      | N          | √      |
| 快速排序 | NlogN      | logN       | ×      |
| 堆排序   | NlogN      | 1          | ×      |
| 计数排序 |            |            | √      |
| 基数排序 |            |            | √      |

优先使用快速排序（常数项低），考虑优先级使用归并排序，考虑空间使用堆排序。

### 常见坑

- 1，归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法” 
- 2， “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2)
- 3，快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01stable sort” 
- 4，所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。
- 5，有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。（类似于快排的partition）

### 工程改进

- 充分利用O(N*logN)和O(N^2)排序各自的优势（快速排序的partition过程中，如果数据量小于K(如60)，则使用插入排序）
- 稳定性的考虑（如基础结构排序使用快排，不需要稳定性；自定义结构排序使用归并，需要稳定性）

 ## 哈希表和有序表

- 哈希表 HashMap、HashSet
  - 时间复杂度O(1)，常数项时间大
- 有序表 TreeMap、TreeSet
  - 时间复杂度O(logN)
  - 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构
  - K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。
  - K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。
  - K floorKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的前一个。
  - K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个。

## 单链表

### 链表解题思路

- 笔试时，不太在乎空间复杂度，只为了时间复杂度
- 面试时，在做到时间复杂度最小时，保证空间最小
- 重要技巧
  - 额外数据结构记录（哈希表等）
  - 快慢指针（慢指针停在哪个位置，看具体需求）

### 如何反转单链表和双向链表？

> 两个指针搞定，p1指向当前节点、p2指向下一个节点

### 打印两个有序链表的公共部分

> 两个指针指向两个链表，谁小谁移动，相同时打印，共同移动，直到指向null。

### 判断链表是否是回文结构coding

> 使用辅助栈
>
> 快慢指针

### 将单向链表按某值划分成左边小、中间相等、右边大的形式

> 笔试：使用数组，将单链表存入数组，进行partition。
>
> 面试：准备六个变量，小于部分的首尾节点、等于部分的首尾节点、大于部分的首尾节点，遍历链表，存入相应部分，最后将三部分首尾相连。

### 复制一个带随机节点的单链表

> 笔试：使用哈希表，key每个原节点，value每个原节点的复制节点
>
> 面试：将链表每个节点的复制点串在原节点后面，遍历链表设置随机节点，最后再分离出新老链表。