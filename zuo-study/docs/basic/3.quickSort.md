## 第三堂课

- 快排的空间复杂度 O(logN)

- 堆结构
- 堆排序
- 比较器的比较 `Comparator`类



## 堆结构

> 逻辑结构：完全二叉树、满二叉树
>
> 存储结构：数组
>
> 新增或删除值的时间复杂度：O(logN)

- 数组中 i 位置节点的左孩子下标 2 * i + 1；右孩子下标 2* i + 2；父节点 (i - 1) / 2

- 分类：大根堆（任意节点大于其子节点）、小根堆（任意节点小于其子节点）

### API(大根堆)

- heapInsert O(logN)

> 添加一个新值，放在数组最后，如果比父节点大，则与父节点交换，直到比父节点小，或成为根节点。从下往上的一个过程。

- heapify O(logN)

> 删去最大值，即位置为0的值。先把数组最后一个节点放在0位置，左右子节点中的较大值大于当前值，则与较大值交换，直到当前位置大于左右子节点或者成为叶子节点。从上往下的一个过程。



### 问题

- 如果在一个大根堆中，将任意一个位置的值改成了新值，如何调整成为大根堆？
  - 如果新值大于旧值，调用heapInsert
  - 如果新值小于旧值，调用heapify
- 给你一个数组，如何快速的调整成大根堆？
  - 方式1，从0遍历数组，每次heapInsert，模拟生成一个大根堆的过程，O(NlogN)
  - 方式2，从数组最后开始遍历，每次heapify，O(N)，速度更快

- 系统自带的堆结构有什么缺点？
- 系统自带的堆，只能操作堆顶元素，而无法操作任意位置的元素（如将任意位置的数改成新值）。需要自己写堆。

### 相关结构

- 优先级队列，实质就是堆结构，Java中是`PriorityQueue`，默认是小根堆

## 堆排序 O(NlogN)

> 先将数组heapInsert成为一个大根堆，再依次把堆顶元素和最后一个值交换，heapSize--，heapify，直到heapSize=0，排序结束。

### 堆排序扩展题目

> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

准备一个大小为k + 1的小根堆，遍历数组，将前k+1个数入堆，堆顶元素出堆放在0下标，再将第k+2个数入堆，依次类推，直到数组中的元素过一次堆。





## 比较器的使用

> 重载比较运算符
>
> Java中的`Comparator`



## 不基于比较的排序算法

- 计数排序，即词频统计排序

> 如问题：一个包含公司员工的年龄数组，请按年龄从小到大排序。

因为年龄范围有限，可以申请一个200的数组，统计年龄出现的次数，再根据词频复写数组。

- 基数排序，即桶排序

> 十进制数排序，准备10个桶（这里一个桶代表一个队列），依次按个位、十位、百位、千位处理，将数组中的每个数入桶，再将桶从左往右依次出桶。

入桶出桶的操作有优化，根据词频统计再组织成前缀和，分片后从右至左遍历数组，根据前缀和确认值的位置。

